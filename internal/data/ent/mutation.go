// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/menta2l/go-hwc/internal/data/ent/cpu"
	"github.com/menta2l/go-hwc/internal/data/ent/disk"
	"github.com/menta2l/go-hwc/internal/data/ent/host"
	"github.com/menta2l/go-hwc/internal/data/ent/netstat"
	"github.com/menta2l/go-hwc/internal/data/ent/network"
	"github.com/menta2l/go-hwc/internal/data/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCpu     = "Cpu"
	TypeDisk    = "Disk"
	TypeHost    = "Host"
	TypeNetstat = "Netstat"
	TypeNetwork = "Network"
)

// CPUMutation represents an operation that mutates the Cpu nodes in the graph.
type CPUMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_CPU           *int
	add_CPU        *int
	vendor_id      *string
	family         *string
	model          *string
	model_name     *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Cpu, error)
	predicates     []predicate.Cpu
}

var _ ent.Mutation = (*CPUMutation)(nil)

// cpuOption allows management of the mutation configuration using functional options.
type cpuOption func(*CPUMutation)

// newCPUMutation creates new mutation for the Cpu entity.
func newCPUMutation(c config, op Op, opts ...cpuOption) *CPUMutation {
	m := &CPUMutation{
		config:        c,
		op:            op,
		typ:           TypeCpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCpuID sets the ID field of the mutation.
func withCpuID(id int) cpuOption {
	return func(m *CPUMutation) {
		var (
			err   error
			once  sync.Once
			value *Cpu
		)
		m.oldValue = func(ctx context.Context) (*Cpu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCpu sets the old Cpu of the mutation.
func withCpu(node *Cpu) cpuOption {
	return func(m *CPUMutation) {
		m.oldValue = func(context.Context) (*Cpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CPUMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CPUMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CPUMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CPUMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cpu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCPU sets the "CPU" field.
func (m *CPUMutation) SetCPU(i int) {
	m._CPU = &i
	m.add_CPU = nil
}

// CPU returns the value of the "CPU" field in the mutation.
func (m *CPUMutation) CPU() (r int, exists bool) {
	v := m._CPU
	if v == nil {
		return
	}
	return *v, true
}

// OldCPU returns the old "CPU" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldCPU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCPU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCPU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCPU: %w", err)
	}
	return oldValue.CPU, nil
}

// AddCPU adds i to the "CPU" field.
func (m *CPUMutation) AddCPU(i int) {
	if m.add_CPU != nil {
		*m.add_CPU += i
	} else {
		m.add_CPU = &i
	}
}

// AddedCPU returns the value that was added to the "CPU" field in this mutation.
func (m *CPUMutation) AddedCPU() (r int, exists bool) {
	v := m.add_CPU
	if v == nil {
		return
	}
	return *v, true
}

// ResetCPU resets all changes to the "CPU" field.
func (m *CPUMutation) ResetCPU() {
	m._CPU = nil
	m.add_CPU = nil
}

// SetVendorID sets the "vendor_id" field.
func (m *CPUMutation) SetVendorID(s string) {
	m.vendor_id = &s
}

// VendorID returns the value of the "vendor_id" field in the mutation.
func (m *CPUMutation) VendorID() (r string, exists bool) {
	v := m.vendor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorID returns the old "vendor_id" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldVendorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorID: %w", err)
	}
	return oldValue.VendorID, nil
}

// ResetVendorID resets all changes to the "vendor_id" field.
func (m *CPUMutation) ResetVendorID() {
	m.vendor_id = nil
}

// SetFamily sets the "family" field.
func (m *CPUMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *CPUMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ResetFamily resets all changes to the "family" field.
func (m *CPUMutation) ResetFamily() {
	m.family = nil
}

// SetModel sets the "model" field.
func (m *CPUMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *CPUMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *CPUMutation) ResetModel() {
	m.model = nil
}

// SetModelName sets the "model_name" field.
func (m *CPUMutation) SetModelName(s string) {
	m.model_name = &s
}

// ModelName returns the value of the "model_name" field in the mutation.
func (m *CPUMutation) ModelName() (r string, exists bool) {
	v := m.model_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModelName returns the old "model_name" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldModelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelName: %w", err)
	}
	return oldValue.ModelName, nil
}

// ResetModelName resets all changes to the "model_name" field.
func (m *CPUMutation) ResetModelName() {
	m.model_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CPUMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CPUMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CPUMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CPUMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CPUMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CPUMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *CPUMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *CPUMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *CPUMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *CPUMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *CPUMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *CPUMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the CPUMutation builder.
func (m *CPUMutation) Where(ps ...predicate.Cpu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CPUMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cpu).
func (m *CPUMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CPUMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._CPU != nil {
		fields = append(fields, cpu.FieldCPU)
	}
	if m.vendor_id != nil {
		fields = append(fields, cpu.FieldVendorID)
	}
	if m.family != nil {
		fields = append(fields, cpu.FieldFamily)
	}
	if m.model != nil {
		fields = append(fields, cpu.FieldModel)
	}
	if m.model_name != nil {
		fields = append(fields, cpu.FieldModelName)
	}
	if m.created_at != nil {
		fields = append(fields, cpu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cpu.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CPUMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cpu.FieldCPU:
		return m.CPU()
	case cpu.FieldVendorID:
		return m.VendorID()
	case cpu.FieldFamily:
		return m.Family()
	case cpu.FieldModel:
		return m.Model()
	case cpu.FieldModelName:
		return m.ModelName()
	case cpu.FieldCreatedAt:
		return m.CreatedAt()
	case cpu.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CPUMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cpu.FieldCPU:
		return m.OldCPU(ctx)
	case cpu.FieldVendorID:
		return m.OldVendorID(ctx)
	case cpu.FieldFamily:
		return m.OldFamily(ctx)
	case cpu.FieldModel:
		return m.OldModel(ctx)
	case cpu.FieldModelName:
		return m.OldModelName(ctx)
	case cpu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cpu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Cpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CPUMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cpu.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCPU(v)
		return nil
	case cpu.FieldVendorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorID(v)
		return nil
	case cpu.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case cpu.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case cpu.FieldModelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelName(v)
		return nil
	case cpu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cpu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Cpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CPUMutation) AddedFields() []string {
	var fields []string
	if m.add_CPU != nil {
		fields = append(fields, cpu.FieldCPU)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CPUMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cpu.FieldCPU:
		return m.AddedCPU()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CPUMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cpu.FieldCPU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCPU(v)
		return nil
	}
	return fmt.Errorf("unknown Cpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CPUMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CPUMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CPUMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CPUMutation) ResetField(name string) error {
	switch name {
	case cpu.FieldCPU:
		m.ResetCPU()
		return nil
	case cpu.FieldVendorID:
		m.ResetVendorID()
		return nil
	case cpu.FieldFamily:
		m.ResetFamily()
		return nil
	case cpu.FieldModel:
		m.ResetModel()
		return nil
	case cpu.FieldModelName:
		m.ResetModelName()
		return nil
	case cpu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cpu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Cpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CPUMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, cpu.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CPUMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cpu.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CPUMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CPUMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CPUMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, cpu.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CPUMutation) EdgeCleared(name string) bool {
	switch name {
	case cpu.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CPUMutation) ClearEdge(name string) error {
	switch name {
	case cpu.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Cpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CPUMutation) ResetEdge(name string) error {
	switch name {
	case cpu.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Cpu edge %s", name)
}

// DiskMutation represents an operation that mutates the Disk nodes in the graph.
type DiskMutation struct {
	config
	op             Op
	typ            string
	id             *int
	device         *string
	_Mountpoint    *string
	_Fstype        *string
	opts           *[]string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Disk, error)
	predicates     []predicate.Disk
}

var _ ent.Mutation = (*DiskMutation)(nil)

// diskOption allows management of the mutation configuration using functional options.
type diskOption func(*DiskMutation)

// newDiskMutation creates new mutation for the Disk entity.
func newDiskMutation(c config, op Op, opts ...diskOption) *DiskMutation {
	m := &DiskMutation{
		config:        c,
		op:            op,
		typ:           TypeDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiskID sets the ID field of the mutation.
func withDiskID(id int) diskOption {
	return func(m *DiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Disk
		)
		m.oldValue = func(ctx context.Context) (*Disk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisk sets the old Disk of the mutation.
func withDisk(node *Disk) diskOption {
	return func(m *DiskMutation) {
		m.oldValue = func(context.Context) (*Disk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDevice sets the "device" field.
func (m *DiskMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *DiskMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *DiskMutation) ResetDevice() {
	m.device = nil
}

// SetMountpoint sets the "Mountpoint" field.
func (m *DiskMutation) SetMountpoint(s string) {
	m._Mountpoint = &s
}

// Mountpoint returns the value of the "Mountpoint" field in the mutation.
func (m *DiskMutation) Mountpoint() (r string, exists bool) {
	v := m._Mountpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldMountpoint returns the old "Mountpoint" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldMountpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMountpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMountpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMountpoint: %w", err)
	}
	return oldValue.Mountpoint, nil
}

// ResetMountpoint resets all changes to the "Mountpoint" field.
func (m *DiskMutation) ResetMountpoint() {
	m._Mountpoint = nil
}

// SetFstype sets the "Fstype" field.
func (m *DiskMutation) SetFstype(s string) {
	m._Fstype = &s
}

// Fstype returns the value of the "Fstype" field in the mutation.
func (m *DiskMutation) Fstype() (r string, exists bool) {
	v := m._Fstype
	if v == nil {
		return
	}
	return *v, true
}

// OldFstype returns the old "Fstype" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldFstype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFstype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFstype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFstype: %w", err)
	}
	return oldValue.Fstype, nil
}

// ResetFstype resets all changes to the "Fstype" field.
func (m *DiskMutation) ResetFstype() {
	m._Fstype = nil
}

// SetOpts sets the "opts" field.
func (m *DiskMutation) SetOpts(s []string) {
	m.opts = &s
}

// Opts returns the value of the "opts" field in the mutation.
func (m *DiskMutation) Opts() (r []string, exists bool) {
	v := m.opts
	if v == nil {
		return
	}
	return *v, true
}

// OldOpts returns the old "opts" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldOpts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpts: %w", err)
	}
	return oldValue.Opts, nil
}

// ClearOpts clears the value of the "opts" field.
func (m *DiskMutation) ClearOpts() {
	m.opts = nil
	m.clearedFields[disk.FieldOpts] = struct{}{}
}

// OptsCleared returns if the "opts" field was cleared in this mutation.
func (m *DiskMutation) OptsCleared() bool {
	_, ok := m.clearedFields[disk.FieldOpts]
	return ok
}

// ResetOpts resets all changes to the "opts" field.
func (m *DiskMutation) ResetOpts() {
	m.opts = nil
	delete(m.clearedFields, disk.FieldOpts)
}

// SetCreatedAt sets the "created_at" field.
func (m *DiskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DiskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DiskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DiskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *DiskMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *DiskMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *DiskMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *DiskMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *DiskMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *DiskMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the DiskMutation builder.
func (m *DiskMutation) Where(ps ...predicate.Disk) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DiskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disk).
func (m *DiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.device != nil {
		fields = append(fields, disk.FieldDevice)
	}
	if m._Mountpoint != nil {
		fields = append(fields, disk.FieldMountpoint)
	}
	if m._Fstype != nil {
		fields = append(fields, disk.FieldFstype)
	}
	if m.opts != nil {
		fields = append(fields, disk.FieldOpts)
	}
	if m.created_at != nil {
		fields = append(fields, disk.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, disk.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldDevice:
		return m.Device()
	case disk.FieldMountpoint:
		return m.Mountpoint()
	case disk.FieldFstype:
		return m.Fstype()
	case disk.FieldOpts:
		return m.Opts()
	case disk.FieldCreatedAt:
		return m.CreatedAt()
	case disk.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disk.FieldDevice:
		return m.OldDevice(ctx)
	case disk.FieldMountpoint:
		return m.OldMountpoint(ctx)
	case disk.FieldFstype:
		return m.OldFstype(ctx)
	case disk.FieldOpts:
		return m.OldOpts(ctx)
	case disk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case disk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Disk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disk.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case disk.FieldMountpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMountpoint(v)
		return nil
	case disk.FieldFstype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFstype(v)
		return nil
	case disk.FieldOpts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpts(v)
		return nil
	case disk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case disk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Disk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(disk.FieldOpts) {
		fields = append(fields, disk.FieldOpts)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiskMutation) ClearField(name string) error {
	switch name {
	case disk.FieldOpts:
		m.ClearOpts()
		return nil
	}
	return fmt.Errorf("unknown Disk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiskMutation) ResetField(name string) error {
	switch name {
	case disk.FieldDevice:
		m.ResetDevice()
		return nil
	case disk.FieldMountpoint:
		m.ResetMountpoint()
		return nil
	case disk.FieldFstype:
		m.ResetFstype()
		return nil
	case disk.FieldOpts:
		m.ResetOpts()
		return nil
	case disk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case disk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, disk.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, disk.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiskMutation) EdgeCleared(name string) bool {
	switch name {
	case disk.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiskMutation) ClearEdge(name string) error {
	switch name {
	case disk.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Disk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiskMutation) ResetEdge(name string) error {
	switch name {
	case disk.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Disk edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	hostname              *string
	os                    *string
	platform              *string
	platform_family       *string
	platform_version      *string
	kernel_version        *string
	kernel_arch           *string
	virtualization_system *string
	virtualization_role   *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	cpu                   map[int]struct{}
	removedcpu            map[int]struct{}
	clearedcpu            bool
	network               map[int]struct{}
	removednetwork        map[int]struct{}
	clearednetwork        bool
	netstat               map[int]struct{}
	removednetstat        map[int]struct{}
	clearednetstat        bool
	disk                  map[int]struct{}
	removeddisk           map[int]struct{}
	cleareddisk           bool
	done                  bool
	oldValue              func(context.Context) (*Host, error)
	predicates            []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id string) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetOs sets the "os" field.
func (m *HostMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *HostMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *HostMutation) ResetOs() {
	m.os = nil
}

// SetPlatform sets the "platform" field.
func (m *HostMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *HostMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *HostMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformFamily sets the "platform_family" field.
func (m *HostMutation) SetPlatformFamily(s string) {
	m.platform_family = &s
}

// PlatformFamily returns the value of the "platform_family" field in the mutation.
func (m *HostMutation) PlatformFamily() (r string, exists bool) {
	v := m.platform_family
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformFamily returns the old "platform_family" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPlatformFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformFamily: %w", err)
	}
	return oldValue.PlatformFamily, nil
}

// ResetPlatformFamily resets all changes to the "platform_family" field.
func (m *HostMutation) ResetPlatformFamily() {
	m.platform_family = nil
}

// SetPlatformVersion sets the "platform_version" field.
func (m *HostMutation) SetPlatformVersion(s string) {
	m.platform_version = &s
}

// PlatformVersion returns the value of the "platform_version" field in the mutation.
func (m *HostMutation) PlatformVersion() (r string, exists bool) {
	v := m.platform_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformVersion returns the old "platform_version" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPlatformVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformVersion: %w", err)
	}
	return oldValue.PlatformVersion, nil
}

// ResetPlatformVersion resets all changes to the "platform_version" field.
func (m *HostMutation) ResetPlatformVersion() {
	m.platform_version = nil
}

// SetKernelVersion sets the "kernel_version" field.
func (m *HostMutation) SetKernelVersion(s string) {
	m.kernel_version = &s
}

// KernelVersion returns the value of the "kernel_version" field in the mutation.
func (m *HostMutation) KernelVersion() (r string, exists bool) {
	v := m.kernel_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKernelVersion returns the old "kernel_version" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldKernelVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKernelVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKernelVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKernelVersion: %w", err)
	}
	return oldValue.KernelVersion, nil
}

// ResetKernelVersion resets all changes to the "kernel_version" field.
func (m *HostMutation) ResetKernelVersion() {
	m.kernel_version = nil
}

// SetKernelArch sets the "kernel_arch" field.
func (m *HostMutation) SetKernelArch(s string) {
	m.kernel_arch = &s
}

// KernelArch returns the value of the "kernel_arch" field in the mutation.
func (m *HostMutation) KernelArch() (r string, exists bool) {
	v := m.kernel_arch
	if v == nil {
		return
	}
	return *v, true
}

// OldKernelArch returns the old "kernel_arch" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldKernelArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKernelArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKernelArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKernelArch: %w", err)
	}
	return oldValue.KernelArch, nil
}

// ResetKernelArch resets all changes to the "kernel_arch" field.
func (m *HostMutation) ResetKernelArch() {
	m.kernel_arch = nil
}

// SetVirtualizationSystem sets the "virtualization_system" field.
func (m *HostMutation) SetVirtualizationSystem(s string) {
	m.virtualization_system = &s
}

// VirtualizationSystem returns the value of the "virtualization_system" field in the mutation.
func (m *HostMutation) VirtualizationSystem() (r string, exists bool) {
	v := m.virtualization_system
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualizationSystem returns the old "virtualization_system" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVirtualizationSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualizationSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualizationSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualizationSystem: %w", err)
	}
	return oldValue.VirtualizationSystem, nil
}

// ResetVirtualizationSystem resets all changes to the "virtualization_system" field.
func (m *HostMutation) ResetVirtualizationSystem() {
	m.virtualization_system = nil
}

// SetVirtualizationRole sets the "virtualization_role" field.
func (m *HostMutation) SetVirtualizationRole(s string) {
	m.virtualization_role = &s
}

// VirtualizationRole returns the value of the "virtualization_role" field in the mutation.
func (m *HostMutation) VirtualizationRole() (r string, exists bool) {
	v := m.virtualization_role
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualizationRole returns the old "virtualization_role" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVirtualizationRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualizationRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualizationRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualizationRole: %w", err)
	}
	return oldValue.VirtualizationRole, nil
}

// ResetVirtualizationRole resets all changes to the "virtualization_role" field.
func (m *HostMutation) ResetVirtualizationRole() {
	m.virtualization_role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCPUIDs adds the "cpu" edge to the Cpu entity by ids.
func (m *HostMutation) AddCPUIDs(ids ...int) {
	if m.cpu == nil {
		m.cpu = make(map[int]struct{})
	}
	for i := range ids {
		m.cpu[ids[i]] = struct{}{}
	}
}

// ClearCPU clears the "cpu" edge to the Cpu entity.
func (m *HostMutation) ClearCPU() {
	m.clearedcpu = true
}

// CPUCleared reports if the "cpu" edge to the Cpu entity was cleared.
func (m *HostMutation) CPUCleared() bool {
	return m.clearedcpu
}

// RemoveCPUIDs removes the "cpu" edge to the Cpu entity by IDs.
func (m *HostMutation) RemoveCPUIDs(ids ...int) {
	if m.removedcpu == nil {
		m.removedcpu = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cpu, ids[i])
		m.removedcpu[ids[i]] = struct{}{}
	}
}

// RemovedCPU returns the removed IDs of the "cpu" edge to the Cpu entity.
func (m *HostMutation) RemovedCPUIDs() (ids []int) {
	for id := range m.removedcpu {
		ids = append(ids, id)
	}
	return
}

// CPUIDs returns the "cpu" edge IDs in the mutation.
func (m *HostMutation) CPUIDs() (ids []int) {
	for id := range m.cpu {
		ids = append(ids, id)
	}
	return
}

// ResetCPU resets all changes to the "cpu" edge.
func (m *HostMutation) ResetCPU() {
	m.cpu = nil
	m.clearedcpu = false
	m.removedcpu = nil
}

// AddNetworkIDs adds the "network" edge to the Network entity by ids.
func (m *HostMutation) AddNetworkIDs(ids ...int) {
	if m.network == nil {
		m.network = make(map[int]struct{})
	}
	for i := range ids {
		m.network[ids[i]] = struct{}{}
	}
}

// ClearNetwork clears the "network" edge to the Network entity.
func (m *HostMutation) ClearNetwork() {
	m.clearednetwork = true
}

// NetworkCleared reports if the "network" edge to the Network entity was cleared.
func (m *HostMutation) NetworkCleared() bool {
	return m.clearednetwork
}

// RemoveNetworkIDs removes the "network" edge to the Network entity by IDs.
func (m *HostMutation) RemoveNetworkIDs(ids ...int) {
	if m.removednetwork == nil {
		m.removednetwork = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.network, ids[i])
		m.removednetwork[ids[i]] = struct{}{}
	}
}

// RemovedNetwork returns the removed IDs of the "network" edge to the Network entity.
func (m *HostMutation) RemovedNetworkIDs() (ids []int) {
	for id := range m.removednetwork {
		ids = append(ids, id)
	}
	return
}

// NetworkIDs returns the "network" edge IDs in the mutation.
func (m *HostMutation) NetworkIDs() (ids []int) {
	for id := range m.network {
		ids = append(ids, id)
	}
	return
}

// ResetNetwork resets all changes to the "network" edge.
func (m *HostMutation) ResetNetwork() {
	m.network = nil
	m.clearednetwork = false
	m.removednetwork = nil
}

// AddNetstatIDs adds the "netstat" edge to the Netstat entity by ids.
func (m *HostMutation) AddNetstatIDs(ids ...int) {
	if m.netstat == nil {
		m.netstat = make(map[int]struct{})
	}
	for i := range ids {
		m.netstat[ids[i]] = struct{}{}
	}
}

// ClearNetstat clears the "netstat" edge to the Netstat entity.
func (m *HostMutation) ClearNetstat() {
	m.clearednetstat = true
}

// NetstatCleared reports if the "netstat" edge to the Netstat entity was cleared.
func (m *HostMutation) NetstatCleared() bool {
	return m.clearednetstat
}

// RemoveNetstatIDs removes the "netstat" edge to the Netstat entity by IDs.
func (m *HostMutation) RemoveNetstatIDs(ids ...int) {
	if m.removednetstat == nil {
		m.removednetstat = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.netstat, ids[i])
		m.removednetstat[ids[i]] = struct{}{}
	}
}

// RemovedNetstat returns the removed IDs of the "netstat" edge to the Netstat entity.
func (m *HostMutation) RemovedNetstatIDs() (ids []int) {
	for id := range m.removednetstat {
		ids = append(ids, id)
	}
	return
}

// NetstatIDs returns the "netstat" edge IDs in the mutation.
func (m *HostMutation) NetstatIDs() (ids []int) {
	for id := range m.netstat {
		ids = append(ids, id)
	}
	return
}

// ResetNetstat resets all changes to the "netstat" edge.
func (m *HostMutation) ResetNetstat() {
	m.netstat = nil
	m.clearednetstat = false
	m.removednetstat = nil
}

// AddDiskIDs adds the "disk" edge to the Disk entity by ids.
func (m *HostMutation) AddDiskIDs(ids ...int) {
	if m.disk == nil {
		m.disk = make(map[int]struct{})
	}
	for i := range ids {
		m.disk[ids[i]] = struct{}{}
	}
}

// ClearDisk clears the "disk" edge to the Disk entity.
func (m *HostMutation) ClearDisk() {
	m.cleareddisk = true
}

// DiskCleared reports if the "disk" edge to the Disk entity was cleared.
func (m *HostMutation) DiskCleared() bool {
	return m.cleareddisk
}

// RemoveDiskIDs removes the "disk" edge to the Disk entity by IDs.
func (m *HostMutation) RemoveDiskIDs(ids ...int) {
	if m.removeddisk == nil {
		m.removeddisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.disk, ids[i])
		m.removeddisk[ids[i]] = struct{}{}
	}
}

// RemovedDisk returns the removed IDs of the "disk" edge to the Disk entity.
func (m *HostMutation) RemovedDiskIDs() (ids []int) {
	for id := range m.removeddisk {
		ids = append(ids, id)
	}
	return
}

// DiskIDs returns the "disk" edge IDs in the mutation.
func (m *HostMutation) DiskIDs() (ids []int) {
	for id := range m.disk {
		ids = append(ids, id)
	}
	return
}

// ResetDisk resets all changes to the "disk" edge.
func (m *HostMutation) ResetDisk() {
	m.disk = nil
	m.cleareddisk = false
	m.removeddisk = nil
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.os != nil {
		fields = append(fields, host.FieldOs)
	}
	if m.platform != nil {
		fields = append(fields, host.FieldPlatform)
	}
	if m.platform_family != nil {
		fields = append(fields, host.FieldPlatformFamily)
	}
	if m.platform_version != nil {
		fields = append(fields, host.FieldPlatformVersion)
	}
	if m.kernel_version != nil {
		fields = append(fields, host.FieldKernelVersion)
	}
	if m.kernel_arch != nil {
		fields = append(fields, host.FieldKernelArch)
	}
	if m.virtualization_system != nil {
		fields = append(fields, host.FieldVirtualizationSystem)
	}
	if m.virtualization_role != nil {
		fields = append(fields, host.FieldVirtualizationRole)
	}
	if m.created_at != nil {
		fields = append(fields, host.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, host.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldOs:
		return m.Os()
	case host.FieldPlatform:
		return m.Platform()
	case host.FieldPlatformFamily:
		return m.PlatformFamily()
	case host.FieldPlatformVersion:
		return m.PlatformVersion()
	case host.FieldKernelVersion:
		return m.KernelVersion()
	case host.FieldKernelArch:
		return m.KernelArch()
	case host.FieldVirtualizationSystem:
		return m.VirtualizationSystem()
	case host.FieldVirtualizationRole:
		return m.VirtualizationRole()
	case host.FieldCreatedAt:
		return m.CreatedAt()
	case host.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldOs:
		return m.OldOs(ctx)
	case host.FieldPlatform:
		return m.OldPlatform(ctx)
	case host.FieldPlatformFamily:
		return m.OldPlatformFamily(ctx)
	case host.FieldPlatformVersion:
		return m.OldPlatformVersion(ctx)
	case host.FieldKernelVersion:
		return m.OldKernelVersion(ctx)
	case host.FieldKernelArch:
		return m.OldKernelArch(ctx)
	case host.FieldVirtualizationSystem:
		return m.OldVirtualizationSystem(ctx)
	case host.FieldVirtualizationRole:
		return m.OldVirtualizationRole(ctx)
	case host.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case host.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case host.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case host.FieldPlatformFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformFamily(v)
		return nil
	case host.FieldPlatformVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformVersion(v)
		return nil
	case host.FieldKernelVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKernelVersion(v)
		return nil
	case host.FieldKernelArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKernelArch(v)
		return nil
	case host.FieldVirtualizationSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualizationSystem(v)
		return nil
	case host.FieldVirtualizationRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualizationRole(v)
		return nil
	case host.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case host.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldOs:
		m.ResetOs()
		return nil
	case host.FieldPlatform:
		m.ResetPlatform()
		return nil
	case host.FieldPlatformFamily:
		m.ResetPlatformFamily()
		return nil
	case host.FieldPlatformVersion:
		m.ResetPlatformVersion()
		return nil
	case host.FieldKernelVersion:
		m.ResetKernelVersion()
		return nil
	case host.FieldKernelArch:
		m.ResetKernelArch()
		return nil
	case host.FieldVirtualizationSystem:
		m.ResetVirtualizationSystem()
		return nil
	case host.FieldVirtualizationRole:
		m.ResetVirtualizationRole()
		return nil
	case host.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case host.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cpu != nil {
		edges = append(edges, host.EdgeCPU)
	}
	if m.network != nil {
		edges = append(edges, host.EdgeNetwork)
	}
	if m.netstat != nil {
		edges = append(edges, host.EdgeNetstat)
	}
	if m.disk != nil {
		edges = append(edges, host.EdgeDisk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeCPU:
		ids := make([]ent.Value, 0, len(m.cpu))
		for id := range m.cpu {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetwork:
		ids := make([]ent.Value, 0, len(m.network))
		for id := range m.network {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetstat:
		ids := make([]ent.Value, 0, len(m.netstat))
		for id := range m.netstat {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDisk:
		ids := make([]ent.Value, 0, len(m.disk))
		for id := range m.disk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcpu != nil {
		edges = append(edges, host.EdgeCPU)
	}
	if m.removednetwork != nil {
		edges = append(edges, host.EdgeNetwork)
	}
	if m.removednetstat != nil {
		edges = append(edges, host.EdgeNetstat)
	}
	if m.removeddisk != nil {
		edges = append(edges, host.EdgeDisk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeCPU:
		ids := make([]ent.Value, 0, len(m.removedcpu))
		for id := range m.removedcpu {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetwork:
		ids := make([]ent.Value, 0, len(m.removednetwork))
		for id := range m.removednetwork {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetstat:
		ids := make([]ent.Value, 0, len(m.removednetstat))
		for id := range m.removednetstat {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDisk:
		ids := make([]ent.Value, 0, len(m.removeddisk))
		for id := range m.removeddisk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcpu {
		edges = append(edges, host.EdgeCPU)
	}
	if m.clearednetwork {
		edges = append(edges, host.EdgeNetwork)
	}
	if m.clearednetstat {
		edges = append(edges, host.EdgeNetstat)
	}
	if m.cleareddisk {
		edges = append(edges, host.EdgeDisk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeCPU:
		return m.clearedcpu
	case host.EdgeNetwork:
		return m.clearednetwork
	case host.EdgeNetstat:
		return m.clearednetstat
	case host.EdgeDisk:
		return m.cleareddisk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeCPU:
		m.ResetCPU()
		return nil
	case host.EdgeNetwork:
		m.ResetNetwork()
		return nil
	case host.EdgeNetstat:
		m.ResetNetstat()
		return nil
	case host.EdgeDisk:
		m.ResetDisk()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// NetstatMutation represents an operation that mutates the Netstat nodes in the graph.
type NetstatMutation struct {
	config
	op             Op
	typ            string
	id             *int
	addr           *string
	port           *uint64
	addport        *int64
	proto          *string
	process        *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Netstat, error)
	predicates     []predicate.Netstat
}

var _ ent.Mutation = (*NetstatMutation)(nil)

// netstatOption allows management of the mutation configuration using functional options.
type netstatOption func(*NetstatMutation)

// newNetstatMutation creates new mutation for the Netstat entity.
func newNetstatMutation(c config, op Op, opts ...netstatOption) *NetstatMutation {
	m := &NetstatMutation{
		config:        c,
		op:            op,
		typ:           TypeNetstat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetstatID sets the ID field of the mutation.
func withNetstatID(id int) netstatOption {
	return func(m *NetstatMutation) {
		var (
			err   error
			once  sync.Once
			value *Netstat
		)
		m.oldValue = func(ctx context.Context) (*Netstat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Netstat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetstat sets the old Netstat of the mutation.
func withNetstat(node *Netstat) netstatOption {
	return func(m *NetstatMutation) {
		m.oldValue = func(context.Context) (*Netstat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetstatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetstatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetstatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetstatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Netstat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddr sets the "addr" field.
func (m *NetstatMutation) SetAddr(s string) {
	m.addr = &s
}

// Addr returns the value of the "addr" field in the mutation.
func (m *NetstatMutation) Addr() (r string, exists bool) {
	v := m.addr
	if v == nil {
		return
	}
	return *v, true
}

// OldAddr returns the old "addr" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddr: %w", err)
	}
	return oldValue.Addr, nil
}

// ResetAddr resets all changes to the "addr" field.
func (m *NetstatMutation) ResetAddr() {
	m.addr = nil
}

// SetPort sets the "port" field.
func (m *NetstatMutation) SetPort(u uint64) {
	m.port = &u
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *NetstatMutation) Port() (r uint64, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldPort(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds u to the "port" field.
func (m *NetstatMutation) AddPort(u int64) {
	if m.addport != nil {
		*m.addport += u
	} else {
		m.addport = &u
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *NetstatMutation) AddedPort() (r int64, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *NetstatMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetProto sets the "proto" field.
func (m *NetstatMutation) SetProto(s string) {
	m.proto = &s
}

// Proto returns the value of the "proto" field in the mutation.
func (m *NetstatMutation) Proto() (r string, exists bool) {
	v := m.proto
	if v == nil {
		return
	}
	return *v, true
}

// OldProto returns the old "proto" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldProto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProto: %w", err)
	}
	return oldValue.Proto, nil
}

// ResetProto resets all changes to the "proto" field.
func (m *NetstatMutation) ResetProto() {
	m.proto = nil
}

// SetProcess sets the "process" field.
func (m *NetstatMutation) SetProcess(s string) {
	m.process = &s
}

// Process returns the value of the "process" field in the mutation.
func (m *NetstatMutation) Process() (r string, exists bool) {
	v := m.process
	if v == nil {
		return
	}
	return *v, true
}

// OldProcess returns the old "process" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldProcess(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcess: %w", err)
	}
	return oldValue.Process, nil
}

// ResetProcess resets all changes to the "process" field.
func (m *NetstatMutation) ResetProcess() {
	m.process = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NetstatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetstatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetstatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NetstatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NetstatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NetstatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *NetstatMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *NetstatMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *NetstatMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *NetstatMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *NetstatMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *NetstatMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the NetstatMutation builder.
func (m *NetstatMutation) Where(ps ...predicate.Netstat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NetstatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Netstat).
func (m *NetstatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetstatMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.addr != nil {
		fields = append(fields, netstat.FieldAddr)
	}
	if m.port != nil {
		fields = append(fields, netstat.FieldPort)
	}
	if m.proto != nil {
		fields = append(fields, netstat.FieldProto)
	}
	if m.process != nil {
		fields = append(fields, netstat.FieldProcess)
	}
	if m.created_at != nil {
		fields = append(fields, netstat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, netstat.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetstatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netstat.FieldAddr:
		return m.Addr()
	case netstat.FieldPort:
		return m.Port()
	case netstat.FieldProto:
		return m.Proto()
	case netstat.FieldProcess:
		return m.Process()
	case netstat.FieldCreatedAt:
		return m.CreatedAt()
	case netstat.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetstatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netstat.FieldAddr:
		return m.OldAddr(ctx)
	case netstat.FieldPort:
		return m.OldPort(ctx)
	case netstat.FieldProto:
		return m.OldProto(ctx)
	case netstat.FieldProcess:
		return m.OldProcess(ctx)
	case netstat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case netstat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Netstat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetstatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netstat.FieldAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddr(v)
		return nil
	case netstat.FieldPort:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case netstat.FieldProto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProto(v)
		return nil
	case netstat.FieldProcess:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcess(v)
		return nil
	case netstat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case netstat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Netstat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetstatMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, netstat.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetstatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case netstat.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetstatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case netstat.FieldPort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Netstat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetstatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetstatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetstatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Netstat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetstatMutation) ResetField(name string) error {
	switch name {
	case netstat.FieldAddr:
		m.ResetAddr()
		return nil
	case netstat.FieldPort:
		m.ResetPort()
		return nil
	case netstat.FieldProto:
		m.ResetProto()
		return nil
	case netstat.FieldProcess:
		m.ResetProcess()
		return nil
	case netstat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case netstat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Netstat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetstatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, netstat.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetstatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netstat.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetstatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetstatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetstatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, netstat.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetstatMutation) EdgeCleared(name string) bool {
	switch name {
	case netstat.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetstatMutation) ClearEdge(name string) error {
	switch name {
	case netstat.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Netstat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetstatMutation) ResetEdge(name string) error {
	switch name {
	case netstat.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Netstat edge %s", name)
}

// NetworkMutation represents an operation that mutates the Network nodes in the graph.
type NetworkMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Index         *int
	add_Index      *int
	_MTU           *int
	add_MTU        *int
	name           *string
	_HardwareAddr  *string
	_Flags         *[]string
	addrs          *[]string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Network, error)
	predicates     []predicate.Network
}

var _ ent.Mutation = (*NetworkMutation)(nil)

// networkOption allows management of the mutation configuration using functional options.
type networkOption func(*NetworkMutation)

// newNetworkMutation creates new mutation for the Network entity.
func newNetworkMutation(c config, op Op, opts ...networkOption) *NetworkMutation {
	m := &NetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkID sets the ID field of the mutation.
func withNetworkID(id int) networkOption {
	return func(m *NetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Network
		)
		m.oldValue = func(ctx context.Context) (*Network, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Network.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetwork sets the old Network of the mutation.
func withNetwork(node *Network) networkOption {
	return func(m *NetworkMutation) {
		m.oldValue = func(context.Context) (*Network, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Network.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIndex sets the "Index" field.
func (m *NetworkMutation) SetIndex(i int) {
	m._Index = &i
	m.add_Index = nil
}

// Index returns the value of the "Index" field in the mutation.
func (m *NetworkMutation) Index() (r int, exists bool) {
	v := m._Index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "Index" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "Index" field.
func (m *NetworkMutation) AddIndex(i int) {
	if m.add_Index != nil {
		*m.add_Index += i
	} else {
		m.add_Index = &i
	}
}

// AddedIndex returns the value that was added to the "Index" field in this mutation.
func (m *NetworkMutation) AddedIndex() (r int, exists bool) {
	v := m.add_Index
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "Index" field.
func (m *NetworkMutation) ResetIndex() {
	m._Index = nil
	m.add_Index = nil
}

// SetMTU sets the "MTU" field.
func (m *NetworkMutation) SetMTU(i int) {
	m._MTU = &i
	m.add_MTU = nil
}

// MTU returns the value of the "MTU" field in the mutation.
func (m *NetworkMutation) MTU() (r int, exists bool) {
	v := m._MTU
	if v == nil {
		return
	}
	return *v, true
}

// OldMTU returns the old "MTU" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldMTU(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMTU is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMTU requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMTU: %w", err)
	}
	return oldValue.MTU, nil
}

// AddMTU adds i to the "MTU" field.
func (m *NetworkMutation) AddMTU(i int) {
	if m.add_MTU != nil {
		*m.add_MTU += i
	} else {
		m.add_MTU = &i
	}
}

// AddedMTU returns the value that was added to the "MTU" field in this mutation.
func (m *NetworkMutation) AddedMTU() (r int, exists bool) {
	v := m.add_MTU
	if v == nil {
		return
	}
	return *v, true
}

// ResetMTU resets all changes to the "MTU" field.
func (m *NetworkMutation) ResetMTU() {
	m._MTU = nil
	m.add_MTU = nil
}

// SetName sets the "name" field.
func (m *NetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkMutation) ResetName() {
	m.name = nil
}

// SetHardwareAddr sets the "HardwareAddr" field.
func (m *NetworkMutation) SetHardwareAddr(s string) {
	m._HardwareAddr = &s
}

// HardwareAddr returns the value of the "HardwareAddr" field in the mutation.
func (m *NetworkMutation) HardwareAddr() (r string, exists bool) {
	v := m._HardwareAddr
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareAddr returns the old "HardwareAddr" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldHardwareAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardwareAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardwareAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareAddr: %w", err)
	}
	return oldValue.HardwareAddr, nil
}

// ResetHardwareAddr resets all changes to the "HardwareAddr" field.
func (m *NetworkMutation) ResetHardwareAddr() {
	m._HardwareAddr = nil
}

// SetFlags sets the "Flags" field.
func (m *NetworkMutation) SetFlags(s []string) {
	m._Flags = &s
}

// Flags returns the value of the "Flags" field in the mutation.
func (m *NetworkMutation) Flags() (r []string, exists bool) {
	v := m._Flags
	if v == nil {
		return
	}
	return *v, true
}

// OldFlags returns the old "Flags" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldFlags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlags: %w", err)
	}
	return oldValue.Flags, nil
}

// ClearFlags clears the value of the "Flags" field.
func (m *NetworkMutation) ClearFlags() {
	m._Flags = nil
	m.clearedFields[network.FieldFlags] = struct{}{}
}

// FlagsCleared returns if the "Flags" field was cleared in this mutation.
func (m *NetworkMutation) FlagsCleared() bool {
	_, ok := m.clearedFields[network.FieldFlags]
	return ok
}

// ResetFlags resets all changes to the "Flags" field.
func (m *NetworkMutation) ResetFlags() {
	m._Flags = nil
	delete(m.clearedFields, network.FieldFlags)
}

// SetAddrs sets the "addrs" field.
func (m *NetworkMutation) SetAddrs(s []string) {
	m.addrs = &s
}

// Addrs returns the value of the "addrs" field in the mutation.
func (m *NetworkMutation) Addrs() (r []string, exists bool) {
	v := m.addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrs returns the old "addrs" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldAddrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrs: %w", err)
	}
	return oldValue.Addrs, nil
}

// ClearAddrs clears the value of the "addrs" field.
func (m *NetworkMutation) ClearAddrs() {
	m.addrs = nil
	m.clearedFields[network.FieldAddrs] = struct{}{}
}

// AddrsCleared returns if the "addrs" field was cleared in this mutation.
func (m *NetworkMutation) AddrsCleared() bool {
	_, ok := m.clearedFields[network.FieldAddrs]
	return ok
}

// ResetAddrs resets all changes to the "addrs" field.
func (m *NetworkMutation) ResetAddrs() {
	m.addrs = nil
	delete(m.clearedFields, network.FieldAddrs)
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NetworkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NetworkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NetworkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *NetworkMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *NetworkMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *NetworkMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *NetworkMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *NetworkMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *NetworkMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the NetworkMutation builder.
func (m *NetworkMutation) Where(ps ...predicate.Network) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Network).
func (m *NetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._Index != nil {
		fields = append(fields, network.FieldIndex)
	}
	if m._MTU != nil {
		fields = append(fields, network.FieldMTU)
	}
	if m.name != nil {
		fields = append(fields, network.FieldName)
	}
	if m._HardwareAddr != nil {
		fields = append(fields, network.FieldHardwareAddr)
	}
	if m._Flags != nil {
		fields = append(fields, network.FieldFlags)
	}
	if m.addrs != nil {
		fields = append(fields, network.FieldAddrs)
	}
	if m.created_at != nil {
		fields = append(fields, network.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, network.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case network.FieldIndex:
		return m.Index()
	case network.FieldMTU:
		return m.MTU()
	case network.FieldName:
		return m.Name()
	case network.FieldHardwareAddr:
		return m.HardwareAddr()
	case network.FieldFlags:
		return m.Flags()
	case network.FieldAddrs:
		return m.Addrs()
	case network.FieldCreatedAt:
		return m.CreatedAt()
	case network.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case network.FieldIndex:
		return m.OldIndex(ctx)
	case network.FieldMTU:
		return m.OldMTU(ctx)
	case network.FieldName:
		return m.OldName(ctx)
	case network.FieldHardwareAddr:
		return m.OldHardwareAddr(ctx)
	case network.FieldFlags:
		return m.OldFlags(ctx)
	case network.FieldAddrs:
		return m.OldAddrs(ctx)
	case network.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case network.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Network field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case network.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case network.FieldMTU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMTU(v)
		return nil
	case network.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case network.FieldHardwareAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareAddr(v)
		return nil
	case network.FieldFlags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlags(v)
		return nil
	case network.FieldAddrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrs(v)
		return nil
	case network.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case network.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkMutation) AddedFields() []string {
	var fields []string
	if m.add_Index != nil {
		fields = append(fields, network.FieldIndex)
	}
	if m.add_MTU != nil {
		fields = append(fields, network.FieldMTU)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case network.FieldIndex:
		return m.AddedIndex()
	case network.FieldMTU:
		return m.AddedMTU()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case network.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case network.FieldMTU:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMTU(v)
		return nil
	}
	return fmt.Errorf("unknown Network numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(network.FieldFlags) {
		fields = append(fields, network.FieldFlags)
	}
	if m.FieldCleared(network.FieldAddrs) {
		fields = append(fields, network.FieldAddrs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMutation) ClearField(name string) error {
	switch name {
	case network.FieldFlags:
		m.ClearFlags()
		return nil
	case network.FieldAddrs:
		m.ClearAddrs()
		return nil
	}
	return fmt.Errorf("unknown Network nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkMutation) ResetField(name string) error {
	switch name {
	case network.FieldIndex:
		m.ResetIndex()
		return nil
	case network.FieldMTU:
		m.ResetMTU()
		return nil
	case network.FieldName:
		m.ResetName()
		return nil
	case network.FieldHardwareAddr:
		m.ResetHardwareAddr()
		return nil
	case network.FieldFlags:
		m.ResetFlags()
		return nil
	case network.FieldAddrs:
		m.ResetAddrs()
		return nil
	case network.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case network.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, network.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, network.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case network.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkMutation) ClearEdge(name string) error {
	switch name {
	case network.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Network unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkMutation) ResetEdge(name string) error {
	switch name {
	case network.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Network edge %s", name)
}
