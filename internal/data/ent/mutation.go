// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/jackc/pgtype"
	"github.com/menta2l/go-hwc/internal/data/ent/cpu"
	"github.com/menta2l/go-hwc/internal/data/ent/disk"
	"github.com/menta2l/go-hwc/internal/data/ent/host"
	"github.com/menta2l/go-hwc/internal/data/ent/netstat"
	"github.com/menta2l/go-hwc/internal/data/ent/network"
	"github.com/menta2l/go-hwc/internal/data/ent/predicate"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCpu     = "Cpu"
	TypeDisk    = "Disk"
	TypeHost    = "Host"
	TypeNetstat = "Netstat"
	TypeNetwork = "Network"
)

// CPUMutation represents an operation that mutates the Cpu nodes in the graph.
type CPUMutation struct {
	config
	op             Op
	typ            string
	id             *int
	vendor_id      *string
	family         *string
	model          *string
	model_name     *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Cpu, error)
	predicates     []predicate.Cpu
}

var _ ent.Mutation = (*CPUMutation)(nil)

// cpuOption allows management of the mutation configuration using functional options.
type cpuOption func(*CPUMutation)

// newCPUMutation creates new mutation for the Cpu entity.
func newCPUMutation(c config, op Op, opts ...cpuOption) *CPUMutation {
	m := &CPUMutation{
		config:        c,
		op:            op,
		typ:           TypeCpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCpuID sets the ID field of the mutation.
func withCpuID(id int) cpuOption {
	return func(m *CPUMutation) {
		var (
			err   error
			once  sync.Once
			value *Cpu
		)
		m.oldValue = func(ctx context.Context) (*Cpu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cpu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCpu sets the old Cpu of the mutation.
func withCpu(node *Cpu) cpuOption {
	return func(m *CPUMutation) {
		m.oldValue = func(context.Context) (*Cpu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CPUMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CPUMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CPUMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CPUMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cpu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVendorID sets the "vendor_id" field.
func (m *CPUMutation) SetVendorID(s string) {
	m.vendor_id = &s
}

// VendorID returns the value of the "vendor_id" field in the mutation.
func (m *CPUMutation) VendorID() (r string, exists bool) {
	v := m.vendor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorID returns the old "vendor_id" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldVendorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorID: %w", err)
	}
	return oldValue.VendorID, nil
}

// ResetVendorID resets all changes to the "vendor_id" field.
func (m *CPUMutation) ResetVendorID() {
	m.vendor_id = nil
}

// SetFamily sets the "family" field.
func (m *CPUMutation) SetFamily(s string) {
	m.family = &s
}

// Family returns the value of the "family" field in the mutation.
func (m *CPUMutation) Family() (r string, exists bool) {
	v := m.family
	if v == nil {
		return
	}
	return *v, true
}

// OldFamily returns the old "family" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamily: %w", err)
	}
	return oldValue.Family, nil
}

// ResetFamily resets all changes to the "family" field.
func (m *CPUMutation) ResetFamily() {
	m.family = nil
}

// SetModel sets the "model" field.
func (m *CPUMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *CPUMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *CPUMutation) ResetModel() {
	m.model = nil
}

// SetModelName sets the "model_name" field.
func (m *CPUMutation) SetModelName(s string) {
	m.model_name = &s
}

// ModelName returns the value of the "model_name" field in the mutation.
func (m *CPUMutation) ModelName() (r string, exists bool) {
	v := m.model_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModelName returns the old "model_name" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldModelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelName: %w", err)
	}
	return oldValue.ModelName, nil
}

// ResetModelName resets all changes to the "model_name" field.
func (m *CPUMutation) ResetModelName() {
	m.model_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CPUMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CPUMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CPUMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CPUMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CPUMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cpu entity.
// If the Cpu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CPUMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CPUMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *CPUMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *CPUMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *CPUMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *CPUMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *CPUMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *CPUMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the CPUMutation builder.
func (m *CPUMutation) Where(ps ...predicate.Cpu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CPUMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cpu).
func (m *CPUMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CPUMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.vendor_id != nil {
		fields = append(fields, cpu.FieldVendorID)
	}
	if m.family != nil {
		fields = append(fields, cpu.FieldFamily)
	}
	if m.model != nil {
		fields = append(fields, cpu.FieldModel)
	}
	if m.model_name != nil {
		fields = append(fields, cpu.FieldModelName)
	}
	if m.created_at != nil {
		fields = append(fields, cpu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cpu.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CPUMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cpu.FieldVendorID:
		return m.VendorID()
	case cpu.FieldFamily:
		return m.Family()
	case cpu.FieldModel:
		return m.Model()
	case cpu.FieldModelName:
		return m.ModelName()
	case cpu.FieldCreatedAt:
		return m.CreatedAt()
	case cpu.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CPUMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cpu.FieldVendorID:
		return m.OldVendorID(ctx)
	case cpu.FieldFamily:
		return m.OldFamily(ctx)
	case cpu.FieldModel:
		return m.OldModel(ctx)
	case cpu.FieldModelName:
		return m.OldModelName(ctx)
	case cpu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cpu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Cpu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CPUMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cpu.FieldVendorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorID(v)
		return nil
	case cpu.FieldFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamily(v)
		return nil
	case cpu.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case cpu.FieldModelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelName(v)
		return nil
	case cpu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cpu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Cpu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CPUMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CPUMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CPUMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cpu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CPUMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CPUMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CPUMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cpu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CPUMutation) ResetField(name string) error {
	switch name {
	case cpu.FieldVendorID:
		m.ResetVendorID()
		return nil
	case cpu.FieldFamily:
		m.ResetFamily()
		return nil
	case cpu.FieldModel:
		m.ResetModel()
		return nil
	case cpu.FieldModelName:
		m.ResetModelName()
		return nil
	case cpu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cpu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Cpu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CPUMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, cpu.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CPUMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cpu.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CPUMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CPUMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CPUMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, cpu.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CPUMutation) EdgeCleared(name string) bool {
	switch name {
	case cpu.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CPUMutation) ClearEdge(name string) error {
	switch name {
	case cpu.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Cpu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CPUMutation) ResetEdge(name string) error {
	switch name {
	case cpu.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Cpu edge %s", name)
}

// DiskMutation represents an operation that mutates the Disk nodes in the graph.
type DiskMutation struct {
	config
	op             Op
	typ            string
	id             *int
	device         *string
	mount          *string
	fs_type        *string
	opts           **pgtype.TextArray
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Disk, error)
	predicates     []predicate.Disk
}

var _ ent.Mutation = (*DiskMutation)(nil)

// diskOption allows management of the mutation configuration using functional options.
type diskOption func(*DiskMutation)

// newDiskMutation creates new mutation for the Disk entity.
func newDiskMutation(c config, op Op, opts ...diskOption) *DiskMutation {
	m := &DiskMutation{
		config:        c,
		op:            op,
		typ:           TypeDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiskID sets the ID field of the mutation.
func withDiskID(id int) diskOption {
	return func(m *DiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Disk
		)
		m.oldValue = func(ctx context.Context) (*Disk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisk sets the old Disk of the mutation.
func withDisk(node *Disk) diskOption {
	return func(m *DiskMutation) {
		m.oldValue = func(context.Context) (*Disk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDevice sets the "device" field.
func (m *DiskMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *DiskMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *DiskMutation) ResetDevice() {
	m.device = nil
}

// SetMount sets the "mount" field.
func (m *DiskMutation) SetMount(s string) {
	m.mount = &s
}

// Mount returns the value of the "mount" field in the mutation.
func (m *DiskMutation) Mount() (r string, exists bool) {
	v := m.mount
	if v == nil {
		return
	}
	return *v, true
}

// OldMount returns the old "mount" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldMount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMount: %w", err)
	}
	return oldValue.Mount, nil
}

// ResetMount resets all changes to the "mount" field.
func (m *DiskMutation) ResetMount() {
	m.mount = nil
}

// SetFsType sets the "fs_type" field.
func (m *DiskMutation) SetFsType(s string) {
	m.fs_type = &s
}

// FsType returns the value of the "fs_type" field in the mutation.
func (m *DiskMutation) FsType() (r string, exists bool) {
	v := m.fs_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFsType returns the old "fs_type" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldFsType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFsType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFsType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFsType: %w", err)
	}
	return oldValue.FsType, nil
}

// ResetFsType resets all changes to the "fs_type" field.
func (m *DiskMutation) ResetFsType() {
	m.fs_type = nil
}

// SetOpts sets the "opts" field.
func (m *DiskMutation) SetOpts(pa *pgtype.TextArray) {
	m.opts = &pa
}

// Opts returns the value of the "opts" field in the mutation.
func (m *DiskMutation) Opts() (r *pgtype.TextArray, exists bool) {
	v := m.opts
	if v == nil {
		return
	}
	return *v, true
}

// OldOpts returns the old "opts" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldOpts(ctx context.Context) (v *pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpts: %w", err)
	}
	return oldValue.Opts, nil
}

// ResetOpts resets all changes to the "opts" field.
func (m *DiskMutation) ResetOpts() {
	m.opts = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DiskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DiskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DiskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DiskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *DiskMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *DiskMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *DiskMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *DiskMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *DiskMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *DiskMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the DiskMutation builder.
func (m *DiskMutation) Where(ps ...predicate.Disk) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DiskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disk).
func (m *DiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.device != nil {
		fields = append(fields, disk.FieldDevice)
	}
	if m.mount != nil {
		fields = append(fields, disk.FieldMount)
	}
	if m.fs_type != nil {
		fields = append(fields, disk.FieldFsType)
	}
	if m.opts != nil {
		fields = append(fields, disk.FieldOpts)
	}
	if m.created_at != nil {
		fields = append(fields, disk.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, disk.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldDevice:
		return m.Device()
	case disk.FieldMount:
		return m.Mount()
	case disk.FieldFsType:
		return m.FsType()
	case disk.FieldOpts:
		return m.Opts()
	case disk.FieldCreatedAt:
		return m.CreatedAt()
	case disk.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disk.FieldDevice:
		return m.OldDevice(ctx)
	case disk.FieldMount:
		return m.OldMount(ctx)
	case disk.FieldFsType:
		return m.OldFsType(ctx)
	case disk.FieldOpts:
		return m.OldOpts(ctx)
	case disk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case disk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Disk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disk.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case disk.FieldMount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMount(v)
		return nil
	case disk.FieldFsType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFsType(v)
		return nil
	case disk.FieldOpts:
		v, ok := value.(*pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpts(v)
		return nil
	case disk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case disk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Disk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiskMutation) ResetField(name string) error {
	switch name {
	case disk.FieldDevice:
		m.ResetDevice()
		return nil
	case disk.FieldMount:
		m.ResetMount()
		return nil
	case disk.FieldFsType:
		m.ResetFsType()
		return nil
	case disk.FieldOpts:
		m.ResetOpts()
		return nil
	case disk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case disk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, disk.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, disk.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiskMutation) EdgeCleared(name string) bool {
	switch name {
	case disk.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiskMutation) ClearEdge(name string) error {
	switch name {
	case disk.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Disk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiskMutation) ResetEdge(name string) error {
	switch name {
	case disk.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Disk edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	hostname              *string
	os                    *string
	platform              *string
	platform_family       *string
	platform_version      *string
	kernel_version        *string
	kernel_arch           *string
	virtualization_system *string
	virtualization_role   *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	cpu_id                map[int]struct{}
	removedcpu_id         map[int]struct{}
	clearedcpu_id         bool
	network_id            map[int]struct{}
	removednetwork_id     map[int]struct{}
	clearednetwork_id     bool
	netstat_id            map[int]struct{}
	removednetstat_id     map[int]struct{}
	clearednetstat_id     bool
	disk_id               map[int]struct{}
	removeddisk_id        map[int]struct{}
	cleareddisk_id        bool
	done                  bool
	oldValue              func(context.Context) (*Host, error)
	predicates            []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id string) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetOs sets the "os" field.
func (m *HostMutation) SetOs(s string) {
	m.os = &s
}

// Os returns the value of the "os" field in the mutation.
func (m *HostMutation) Os() (r string, exists bool) {
	v := m.os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "os" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "os" field.
func (m *HostMutation) ResetOs() {
	m.os = nil
}

// SetPlatform sets the "platform" field.
func (m *HostMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *HostMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *HostMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformFamily sets the "platform_family" field.
func (m *HostMutation) SetPlatformFamily(s string) {
	m.platform_family = &s
}

// PlatformFamily returns the value of the "platform_family" field in the mutation.
func (m *HostMutation) PlatformFamily() (r string, exists bool) {
	v := m.platform_family
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformFamily returns the old "platform_family" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPlatformFamily(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformFamily is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformFamily requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformFamily: %w", err)
	}
	return oldValue.PlatformFamily, nil
}

// ResetPlatformFamily resets all changes to the "platform_family" field.
func (m *HostMutation) ResetPlatformFamily() {
	m.platform_family = nil
}

// SetPlatformVersion sets the "platform_version" field.
func (m *HostMutation) SetPlatformVersion(s string) {
	m.platform_version = &s
}

// PlatformVersion returns the value of the "platform_version" field in the mutation.
func (m *HostMutation) PlatformVersion() (r string, exists bool) {
	v := m.platform_version
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformVersion returns the old "platform_version" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldPlatformVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformVersion: %w", err)
	}
	return oldValue.PlatformVersion, nil
}

// ResetPlatformVersion resets all changes to the "platform_version" field.
func (m *HostMutation) ResetPlatformVersion() {
	m.platform_version = nil
}

// SetKernelVersion sets the "kernel_version" field.
func (m *HostMutation) SetKernelVersion(s string) {
	m.kernel_version = &s
}

// KernelVersion returns the value of the "kernel_version" field in the mutation.
func (m *HostMutation) KernelVersion() (r string, exists bool) {
	v := m.kernel_version
	if v == nil {
		return
	}
	return *v, true
}

// OldKernelVersion returns the old "kernel_version" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldKernelVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKernelVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKernelVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKernelVersion: %w", err)
	}
	return oldValue.KernelVersion, nil
}

// ResetKernelVersion resets all changes to the "kernel_version" field.
func (m *HostMutation) ResetKernelVersion() {
	m.kernel_version = nil
}

// SetKernelArch sets the "kernel_arch" field.
func (m *HostMutation) SetKernelArch(s string) {
	m.kernel_arch = &s
}

// KernelArch returns the value of the "kernel_arch" field in the mutation.
func (m *HostMutation) KernelArch() (r string, exists bool) {
	v := m.kernel_arch
	if v == nil {
		return
	}
	return *v, true
}

// OldKernelArch returns the old "kernel_arch" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldKernelArch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKernelArch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKernelArch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKernelArch: %w", err)
	}
	return oldValue.KernelArch, nil
}

// ResetKernelArch resets all changes to the "kernel_arch" field.
func (m *HostMutation) ResetKernelArch() {
	m.kernel_arch = nil
}

// SetVirtualizationSystem sets the "virtualization_system" field.
func (m *HostMutation) SetVirtualizationSystem(s string) {
	m.virtualization_system = &s
}

// VirtualizationSystem returns the value of the "virtualization_system" field in the mutation.
func (m *HostMutation) VirtualizationSystem() (r string, exists bool) {
	v := m.virtualization_system
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualizationSystem returns the old "virtualization_system" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVirtualizationSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualizationSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualizationSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualizationSystem: %w", err)
	}
	return oldValue.VirtualizationSystem, nil
}

// ResetVirtualizationSystem resets all changes to the "virtualization_system" field.
func (m *HostMutation) ResetVirtualizationSystem() {
	m.virtualization_system = nil
}

// SetVirtualizationRole sets the "virtualization_role" field.
func (m *HostMutation) SetVirtualizationRole(s string) {
	m.virtualization_role = &s
}

// VirtualizationRole returns the value of the "virtualization_role" field in the mutation.
func (m *HostMutation) VirtualizationRole() (r string, exists bool) {
	v := m.virtualization_role
	if v == nil {
		return
	}
	return *v, true
}

// OldVirtualizationRole returns the old "virtualization_role" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVirtualizationRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVirtualizationRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVirtualizationRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVirtualizationRole: %w", err)
	}
	return oldValue.VirtualizationRole, nil
}

// ResetVirtualizationRole resets all changes to the "virtualization_role" field.
func (m *HostMutation) ResetVirtualizationRole() {
	m.virtualization_role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddCPUIDIDs adds the "cpu_id" edge to the Cpu entity by ids.
func (m *HostMutation) AddCPUIDIDs(ids ...int) {
	if m.cpu_id == nil {
		m.cpu_id = make(map[int]struct{})
	}
	for i := range ids {
		m.cpu_id[ids[i]] = struct{}{}
	}
}

// ClearCPUID clears the "cpu_id" edge to the Cpu entity.
func (m *HostMutation) ClearCPUID() {
	m.clearedcpu_id = true
}

// CPUIDCleared reports if the "cpu_id" edge to the Cpu entity was cleared.
func (m *HostMutation) CPUIDCleared() bool {
	return m.clearedcpu_id
}

// RemoveCPUIDIDs removes the "cpu_id" edge to the Cpu entity by IDs.
func (m *HostMutation) RemoveCPUIDIDs(ids ...int) {
	if m.removedcpu_id == nil {
		m.removedcpu_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cpu_id, ids[i])
		m.removedcpu_id[ids[i]] = struct{}{}
	}
}

// RemovedCPUID returns the removed IDs of the "cpu_id" edge to the Cpu entity.
func (m *HostMutation) RemovedCPUIDIDs() (ids []int) {
	for id := range m.removedcpu_id {
		ids = append(ids, id)
	}
	return
}

// CPUIDIDs returns the "cpu_id" edge IDs in the mutation.
func (m *HostMutation) CPUIDIDs() (ids []int) {
	for id := range m.cpu_id {
		ids = append(ids, id)
	}
	return
}

// ResetCPUID resets all changes to the "cpu_id" edge.
func (m *HostMutation) ResetCPUID() {
	m.cpu_id = nil
	m.clearedcpu_id = false
	m.removedcpu_id = nil
}

// AddNetworkIDIDs adds the "network_id" edge to the Network entity by ids.
func (m *HostMutation) AddNetworkIDIDs(ids ...int) {
	if m.network_id == nil {
		m.network_id = make(map[int]struct{})
	}
	for i := range ids {
		m.network_id[ids[i]] = struct{}{}
	}
}

// ClearNetworkID clears the "network_id" edge to the Network entity.
func (m *HostMutation) ClearNetworkID() {
	m.clearednetwork_id = true
}

// NetworkIDCleared reports if the "network_id" edge to the Network entity was cleared.
func (m *HostMutation) NetworkIDCleared() bool {
	return m.clearednetwork_id
}

// RemoveNetworkIDIDs removes the "network_id" edge to the Network entity by IDs.
func (m *HostMutation) RemoveNetworkIDIDs(ids ...int) {
	if m.removednetwork_id == nil {
		m.removednetwork_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.network_id, ids[i])
		m.removednetwork_id[ids[i]] = struct{}{}
	}
}

// RemovedNetworkID returns the removed IDs of the "network_id" edge to the Network entity.
func (m *HostMutation) RemovedNetworkIDIDs() (ids []int) {
	for id := range m.removednetwork_id {
		ids = append(ids, id)
	}
	return
}

// NetworkIDIDs returns the "network_id" edge IDs in the mutation.
func (m *HostMutation) NetworkIDIDs() (ids []int) {
	for id := range m.network_id {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkID resets all changes to the "network_id" edge.
func (m *HostMutation) ResetNetworkID() {
	m.network_id = nil
	m.clearednetwork_id = false
	m.removednetwork_id = nil
}

// AddNetstatIDIDs adds the "netstat_id" edge to the Netstat entity by ids.
func (m *HostMutation) AddNetstatIDIDs(ids ...int) {
	if m.netstat_id == nil {
		m.netstat_id = make(map[int]struct{})
	}
	for i := range ids {
		m.netstat_id[ids[i]] = struct{}{}
	}
}

// ClearNetstatID clears the "netstat_id" edge to the Netstat entity.
func (m *HostMutation) ClearNetstatID() {
	m.clearednetstat_id = true
}

// NetstatIDCleared reports if the "netstat_id" edge to the Netstat entity was cleared.
func (m *HostMutation) NetstatIDCleared() bool {
	return m.clearednetstat_id
}

// RemoveNetstatIDIDs removes the "netstat_id" edge to the Netstat entity by IDs.
func (m *HostMutation) RemoveNetstatIDIDs(ids ...int) {
	if m.removednetstat_id == nil {
		m.removednetstat_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.netstat_id, ids[i])
		m.removednetstat_id[ids[i]] = struct{}{}
	}
}

// RemovedNetstatID returns the removed IDs of the "netstat_id" edge to the Netstat entity.
func (m *HostMutation) RemovedNetstatIDIDs() (ids []int) {
	for id := range m.removednetstat_id {
		ids = append(ids, id)
	}
	return
}

// NetstatIDIDs returns the "netstat_id" edge IDs in the mutation.
func (m *HostMutation) NetstatIDIDs() (ids []int) {
	for id := range m.netstat_id {
		ids = append(ids, id)
	}
	return
}

// ResetNetstatID resets all changes to the "netstat_id" edge.
func (m *HostMutation) ResetNetstatID() {
	m.netstat_id = nil
	m.clearednetstat_id = false
	m.removednetstat_id = nil
}

// AddDiskIDIDs adds the "disk_id" edge to the Disk entity by ids.
func (m *HostMutation) AddDiskIDIDs(ids ...int) {
	if m.disk_id == nil {
		m.disk_id = make(map[int]struct{})
	}
	for i := range ids {
		m.disk_id[ids[i]] = struct{}{}
	}
}

// ClearDiskID clears the "disk_id" edge to the Disk entity.
func (m *HostMutation) ClearDiskID() {
	m.cleareddisk_id = true
}

// DiskIDCleared reports if the "disk_id" edge to the Disk entity was cleared.
func (m *HostMutation) DiskIDCleared() bool {
	return m.cleareddisk_id
}

// RemoveDiskIDIDs removes the "disk_id" edge to the Disk entity by IDs.
func (m *HostMutation) RemoveDiskIDIDs(ids ...int) {
	if m.removeddisk_id == nil {
		m.removeddisk_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.disk_id, ids[i])
		m.removeddisk_id[ids[i]] = struct{}{}
	}
}

// RemovedDiskID returns the removed IDs of the "disk_id" edge to the Disk entity.
func (m *HostMutation) RemovedDiskIDIDs() (ids []int) {
	for id := range m.removeddisk_id {
		ids = append(ids, id)
	}
	return
}

// DiskIDIDs returns the "disk_id" edge IDs in the mutation.
func (m *HostMutation) DiskIDIDs() (ids []int) {
	for id := range m.disk_id {
		ids = append(ids, id)
	}
	return
}

// ResetDiskID resets all changes to the "disk_id" edge.
func (m *HostMutation) ResetDiskID() {
	m.disk_id = nil
	m.cleareddisk_id = false
	m.removeddisk_id = nil
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.os != nil {
		fields = append(fields, host.FieldOs)
	}
	if m.platform != nil {
		fields = append(fields, host.FieldPlatform)
	}
	if m.platform_family != nil {
		fields = append(fields, host.FieldPlatformFamily)
	}
	if m.platform_version != nil {
		fields = append(fields, host.FieldPlatformVersion)
	}
	if m.kernel_version != nil {
		fields = append(fields, host.FieldKernelVersion)
	}
	if m.kernel_arch != nil {
		fields = append(fields, host.FieldKernelArch)
	}
	if m.virtualization_system != nil {
		fields = append(fields, host.FieldVirtualizationSystem)
	}
	if m.virtualization_role != nil {
		fields = append(fields, host.FieldVirtualizationRole)
	}
	if m.created_at != nil {
		fields = append(fields, host.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, host.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldOs:
		return m.Os()
	case host.FieldPlatform:
		return m.Platform()
	case host.FieldPlatformFamily:
		return m.PlatformFamily()
	case host.FieldPlatformVersion:
		return m.PlatformVersion()
	case host.FieldKernelVersion:
		return m.KernelVersion()
	case host.FieldKernelArch:
		return m.KernelArch()
	case host.FieldVirtualizationSystem:
		return m.VirtualizationSystem()
	case host.FieldVirtualizationRole:
		return m.VirtualizationRole()
	case host.FieldCreatedAt:
		return m.CreatedAt()
	case host.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldOs:
		return m.OldOs(ctx)
	case host.FieldPlatform:
		return m.OldPlatform(ctx)
	case host.FieldPlatformFamily:
		return m.OldPlatformFamily(ctx)
	case host.FieldPlatformVersion:
		return m.OldPlatformVersion(ctx)
	case host.FieldKernelVersion:
		return m.OldKernelVersion(ctx)
	case host.FieldKernelArch:
		return m.OldKernelArch(ctx)
	case host.FieldVirtualizationSystem:
		return m.OldVirtualizationSystem(ctx)
	case host.FieldVirtualizationRole:
		return m.OldVirtualizationRole(ctx)
	case host.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case host.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case host.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case host.FieldPlatformFamily:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformFamily(v)
		return nil
	case host.FieldPlatformVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformVersion(v)
		return nil
	case host.FieldKernelVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKernelVersion(v)
		return nil
	case host.FieldKernelArch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKernelArch(v)
		return nil
	case host.FieldVirtualizationSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualizationSystem(v)
		return nil
	case host.FieldVirtualizationRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVirtualizationRole(v)
		return nil
	case host.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case host.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldOs:
		m.ResetOs()
		return nil
	case host.FieldPlatform:
		m.ResetPlatform()
		return nil
	case host.FieldPlatformFamily:
		m.ResetPlatformFamily()
		return nil
	case host.FieldPlatformVersion:
		m.ResetPlatformVersion()
		return nil
	case host.FieldKernelVersion:
		m.ResetKernelVersion()
		return nil
	case host.FieldKernelArch:
		m.ResetKernelArch()
		return nil
	case host.FieldVirtualizationSystem:
		m.ResetVirtualizationSystem()
		return nil
	case host.FieldVirtualizationRole:
		m.ResetVirtualizationRole()
		return nil
	case host.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case host.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cpu_id != nil {
		edges = append(edges, host.EdgeCPUID)
	}
	if m.network_id != nil {
		edges = append(edges, host.EdgeNetworkID)
	}
	if m.netstat_id != nil {
		edges = append(edges, host.EdgeNetstatID)
	}
	if m.disk_id != nil {
		edges = append(edges, host.EdgeDiskID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeCPUID:
		ids := make([]ent.Value, 0, len(m.cpu_id))
		for id := range m.cpu_id {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetworkID:
		ids := make([]ent.Value, 0, len(m.network_id))
		for id := range m.network_id {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetstatID:
		ids := make([]ent.Value, 0, len(m.netstat_id))
		for id := range m.netstat_id {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDiskID:
		ids := make([]ent.Value, 0, len(m.disk_id))
		for id := range m.disk_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcpu_id != nil {
		edges = append(edges, host.EdgeCPUID)
	}
	if m.removednetwork_id != nil {
		edges = append(edges, host.EdgeNetworkID)
	}
	if m.removednetstat_id != nil {
		edges = append(edges, host.EdgeNetstatID)
	}
	if m.removeddisk_id != nil {
		edges = append(edges, host.EdgeDiskID)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeCPUID:
		ids := make([]ent.Value, 0, len(m.removedcpu_id))
		for id := range m.removedcpu_id {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetworkID:
		ids := make([]ent.Value, 0, len(m.removednetwork_id))
		for id := range m.removednetwork_id {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeNetstatID:
		ids := make([]ent.Value, 0, len(m.removednetstat_id))
		for id := range m.removednetstat_id {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDiskID:
		ids := make([]ent.Value, 0, len(m.removeddisk_id))
		for id := range m.removeddisk_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcpu_id {
		edges = append(edges, host.EdgeCPUID)
	}
	if m.clearednetwork_id {
		edges = append(edges, host.EdgeNetworkID)
	}
	if m.clearednetstat_id {
		edges = append(edges, host.EdgeNetstatID)
	}
	if m.cleareddisk_id {
		edges = append(edges, host.EdgeDiskID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeCPUID:
		return m.clearedcpu_id
	case host.EdgeNetworkID:
		return m.clearednetwork_id
	case host.EdgeNetstatID:
		return m.clearednetstat_id
	case host.EdgeDiskID:
		return m.cleareddisk_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeCPUID:
		m.ResetCPUID()
		return nil
	case host.EdgeNetworkID:
		m.ResetNetworkID()
		return nil
	case host.EdgeNetstatID:
		m.ResetNetstatID()
		return nil
	case host.EdgeDiskID:
		m.ResetDiskID()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// NetstatMutation represents an operation that mutates the Netstat nodes in the graph.
type NetstatMutation struct {
	config
	op             Op
	typ            string
	id             *int
	addr           *string
	port           *uint64
	addport        *int64
	proto          *string
	process        *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Netstat, error)
	predicates     []predicate.Netstat
}

var _ ent.Mutation = (*NetstatMutation)(nil)

// netstatOption allows management of the mutation configuration using functional options.
type netstatOption func(*NetstatMutation)

// newNetstatMutation creates new mutation for the Netstat entity.
func newNetstatMutation(c config, op Op, opts ...netstatOption) *NetstatMutation {
	m := &NetstatMutation{
		config:        c,
		op:            op,
		typ:           TypeNetstat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetstatID sets the ID field of the mutation.
func withNetstatID(id int) netstatOption {
	return func(m *NetstatMutation) {
		var (
			err   error
			once  sync.Once
			value *Netstat
		)
		m.oldValue = func(ctx context.Context) (*Netstat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Netstat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetstat sets the old Netstat of the mutation.
func withNetstat(node *Netstat) netstatOption {
	return func(m *NetstatMutation) {
		m.oldValue = func(context.Context) (*Netstat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetstatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetstatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetstatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetstatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Netstat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddr sets the "addr" field.
func (m *NetstatMutation) SetAddr(s string) {
	m.addr = &s
}

// Addr returns the value of the "addr" field in the mutation.
func (m *NetstatMutation) Addr() (r string, exists bool) {
	v := m.addr
	if v == nil {
		return
	}
	return *v, true
}

// OldAddr returns the old "addr" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldAddr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddr: %w", err)
	}
	return oldValue.Addr, nil
}

// ResetAddr resets all changes to the "addr" field.
func (m *NetstatMutation) ResetAddr() {
	m.addr = nil
}

// SetPort sets the "port" field.
func (m *NetstatMutation) SetPort(u uint64) {
	m.port = &u
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *NetstatMutation) Port() (r uint64, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldPort(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds u to the "port" field.
func (m *NetstatMutation) AddPort(u int64) {
	if m.addport != nil {
		*m.addport += u
	} else {
		m.addport = &u
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *NetstatMutation) AddedPort() (r int64, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *NetstatMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetProto sets the "proto" field.
func (m *NetstatMutation) SetProto(s string) {
	m.proto = &s
}

// Proto returns the value of the "proto" field in the mutation.
func (m *NetstatMutation) Proto() (r string, exists bool) {
	v := m.proto
	if v == nil {
		return
	}
	return *v, true
}

// OldProto returns the old "proto" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldProto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProto: %w", err)
	}
	return oldValue.Proto, nil
}

// ResetProto resets all changes to the "proto" field.
func (m *NetstatMutation) ResetProto() {
	m.proto = nil
}

// SetProcess sets the "process" field.
func (m *NetstatMutation) SetProcess(s string) {
	m.process = &s
}

// Process returns the value of the "process" field in the mutation.
func (m *NetstatMutation) Process() (r string, exists bool) {
	v := m.process
	if v == nil {
		return
	}
	return *v, true
}

// OldProcess returns the old "process" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldProcess(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcess: %w", err)
	}
	return oldValue.Process, nil
}

// ResetProcess resets all changes to the "process" field.
func (m *NetstatMutation) ResetProcess() {
	m.process = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NetstatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetstatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetstatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NetstatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NetstatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Netstat entity.
// If the Netstat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetstatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NetstatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *NetstatMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *NetstatMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *NetstatMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *NetstatMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *NetstatMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *NetstatMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the NetstatMutation builder.
func (m *NetstatMutation) Where(ps ...predicate.Netstat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NetstatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Netstat).
func (m *NetstatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetstatMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.addr != nil {
		fields = append(fields, netstat.FieldAddr)
	}
	if m.port != nil {
		fields = append(fields, netstat.FieldPort)
	}
	if m.proto != nil {
		fields = append(fields, netstat.FieldProto)
	}
	if m.process != nil {
		fields = append(fields, netstat.FieldProcess)
	}
	if m.created_at != nil {
		fields = append(fields, netstat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, netstat.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetstatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case netstat.FieldAddr:
		return m.Addr()
	case netstat.FieldPort:
		return m.Port()
	case netstat.FieldProto:
		return m.Proto()
	case netstat.FieldProcess:
		return m.Process()
	case netstat.FieldCreatedAt:
		return m.CreatedAt()
	case netstat.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetstatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case netstat.FieldAddr:
		return m.OldAddr(ctx)
	case netstat.FieldPort:
		return m.OldPort(ctx)
	case netstat.FieldProto:
		return m.OldProto(ctx)
	case netstat.FieldProcess:
		return m.OldProcess(ctx)
	case netstat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case netstat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Netstat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetstatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case netstat.FieldAddr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddr(v)
		return nil
	case netstat.FieldPort:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case netstat.FieldProto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProto(v)
		return nil
	case netstat.FieldProcess:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcess(v)
		return nil
	case netstat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case netstat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Netstat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetstatMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, netstat.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetstatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case netstat.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetstatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case netstat.FieldPort:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Netstat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetstatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetstatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetstatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Netstat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetstatMutation) ResetField(name string) error {
	switch name {
	case netstat.FieldAddr:
		m.ResetAddr()
		return nil
	case netstat.FieldPort:
		m.ResetPort()
		return nil
	case netstat.FieldProto:
		m.ResetProto()
		return nil
	case netstat.FieldProcess:
		m.ResetProcess()
		return nil
	case netstat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case netstat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Netstat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetstatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, netstat.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetstatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case netstat.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetstatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetstatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetstatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, netstat.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetstatMutation) EdgeCleared(name string) bool {
	switch name {
	case netstat.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetstatMutation) ClearEdge(name string) error {
	switch name {
	case netstat.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Netstat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetstatMutation) ResetEdge(name string) error {
	switch name {
	case netstat.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Netstat edge %s", name)
}

// NetworkMutation represents an operation that mutates the Network nodes in the graph.
type NetworkMutation struct {
	config
	op             Op
	typ            string
	id             *int
	idx            *int
	addidx         *int
	mtu            *int
	addmtu         *int
	name           *string
	mac            *string
	flags          **pgtype.TextArray
	addrs          **pgtype.TextArray
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	host_id        *string
	clearedhost_id bool
	done           bool
	oldValue       func(context.Context) (*Network, error)
	predicates     []predicate.Network
}

var _ ent.Mutation = (*NetworkMutation)(nil)

// networkOption allows management of the mutation configuration using functional options.
type networkOption func(*NetworkMutation)

// newNetworkMutation creates new mutation for the Network entity.
func newNetworkMutation(c config, op Op, opts ...networkOption) *NetworkMutation {
	m := &NetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkID sets the ID field of the mutation.
func withNetworkID(id int) networkOption {
	return func(m *NetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Network
		)
		m.oldValue = func(ctx context.Context) (*Network, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Network.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetwork sets the old Network of the mutation.
func withNetwork(node *Network) networkOption {
	return func(m *NetworkMutation) {
		m.oldValue = func(context.Context) (*Network, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Network.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdx sets the "idx" field.
func (m *NetworkMutation) SetIdx(i int) {
	m.idx = &i
	m.addidx = nil
}

// Idx returns the value of the "idx" field in the mutation.
func (m *NetworkMutation) Idx() (r int, exists bool) {
	v := m.idx
	if v == nil {
		return
	}
	return *v, true
}

// OldIdx returns the old "idx" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldIdx(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdx: %w", err)
	}
	return oldValue.Idx, nil
}

// AddIdx adds i to the "idx" field.
func (m *NetworkMutation) AddIdx(i int) {
	if m.addidx != nil {
		*m.addidx += i
	} else {
		m.addidx = &i
	}
}

// AddedIdx returns the value that was added to the "idx" field in this mutation.
func (m *NetworkMutation) AddedIdx() (r int, exists bool) {
	v := m.addidx
	if v == nil {
		return
	}
	return *v, true
}

// ResetIdx resets all changes to the "idx" field.
func (m *NetworkMutation) ResetIdx() {
	m.idx = nil
	m.addidx = nil
}

// SetMtu sets the "mtu" field.
func (m *NetworkMutation) SetMtu(i int) {
	m.mtu = &i
	m.addmtu = nil
}

// Mtu returns the value of the "mtu" field in the mutation.
func (m *NetworkMutation) Mtu() (r int, exists bool) {
	v := m.mtu
	if v == nil {
		return
	}
	return *v, true
}

// OldMtu returns the old "mtu" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldMtu(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMtu is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMtu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMtu: %w", err)
	}
	return oldValue.Mtu, nil
}

// AddMtu adds i to the "mtu" field.
func (m *NetworkMutation) AddMtu(i int) {
	if m.addmtu != nil {
		*m.addmtu += i
	} else {
		m.addmtu = &i
	}
}

// AddedMtu returns the value that was added to the "mtu" field in this mutation.
func (m *NetworkMutation) AddedMtu() (r int, exists bool) {
	v := m.addmtu
	if v == nil {
		return
	}
	return *v, true
}

// ResetMtu resets all changes to the "mtu" field.
func (m *NetworkMutation) ResetMtu() {
	m.mtu = nil
	m.addmtu = nil
}

// SetName sets the "name" field.
func (m *NetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkMutation) ResetName() {
	m.name = nil
}

// SetMAC sets the "mac" field.
func (m *NetworkMutation) SetMAC(s string) {
	m.mac = &s
}

// MAC returns the value of the "mac" field in the mutation.
func (m *NetworkMutation) MAC() (r string, exists bool) {
	v := m.mac
	if v == nil {
		return
	}
	return *v, true
}

// OldMAC returns the old "mac" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldMAC(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMAC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMAC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMAC: %w", err)
	}
	return oldValue.MAC, nil
}

// ResetMAC resets all changes to the "mac" field.
func (m *NetworkMutation) ResetMAC() {
	m.mac = nil
}

// SetFlags sets the "flags" field.
func (m *NetworkMutation) SetFlags(pa *pgtype.TextArray) {
	m.flags = &pa
}

// Flags returns the value of the "flags" field in the mutation.
func (m *NetworkMutation) Flags() (r *pgtype.TextArray, exists bool) {
	v := m.flags
	if v == nil {
		return
	}
	return *v, true
}

// OldFlags returns the old "flags" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldFlags(ctx context.Context) (v *pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlags: %w", err)
	}
	return oldValue.Flags, nil
}

// ClearFlags clears the value of the "flags" field.
func (m *NetworkMutation) ClearFlags() {
	m.flags = nil
	m.clearedFields[network.FieldFlags] = struct{}{}
}

// FlagsCleared returns if the "flags" field was cleared in this mutation.
func (m *NetworkMutation) FlagsCleared() bool {
	_, ok := m.clearedFields[network.FieldFlags]
	return ok
}

// ResetFlags resets all changes to the "flags" field.
func (m *NetworkMutation) ResetFlags() {
	m.flags = nil
	delete(m.clearedFields, network.FieldFlags)
}

// SetAddrs sets the "addrs" field.
func (m *NetworkMutation) SetAddrs(pa *pgtype.TextArray) {
	m.addrs = &pa
}

// Addrs returns the value of the "addrs" field in the mutation.
func (m *NetworkMutation) Addrs() (r *pgtype.TextArray, exists bool) {
	v := m.addrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAddrs returns the old "addrs" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldAddrs(ctx context.Context) (v *pgtype.TextArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddrs: %w", err)
	}
	return oldValue.Addrs, nil
}

// ClearAddrs clears the value of the "addrs" field.
func (m *NetworkMutation) ClearAddrs() {
	m.addrs = nil
	m.clearedFields[network.FieldAddrs] = struct{}{}
}

// AddrsCleared returns if the "addrs" field was cleared in this mutation.
func (m *NetworkMutation) AddrsCleared() bool {
	_, ok := m.clearedFields[network.FieldAddrs]
	return ok
}

// ResetAddrs resets all changes to the "addrs" field.
func (m *NetworkMutation) ResetAddrs() {
	m.addrs = nil
	delete(m.clearedFields, network.FieldAddrs)
}

// SetCreatedAt sets the "created_at" field.
func (m *NetworkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NetworkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NetworkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NetworkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NetworkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NetworkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHostIDID sets the "host_id" edge to the Host entity by id.
func (m *NetworkMutation) SetHostIDID(id string) {
	m.host_id = &id
}

// ClearHostID clears the "host_id" edge to the Host entity.
func (m *NetworkMutation) ClearHostID() {
	m.clearedhost_id = true
}

// HostIDCleared reports if the "host_id" edge to the Host entity was cleared.
func (m *NetworkMutation) HostIDCleared() bool {
	return m.clearedhost_id
}

// HostIDID returns the "host_id" edge ID in the mutation.
func (m *NetworkMutation) HostIDID() (id string, exists bool) {
	if m.host_id != nil {
		return *m.host_id, true
	}
	return
}

// HostIDIDs returns the "host_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostIDID instead. It exists only for internal usage by the builders.
func (m *NetworkMutation) HostIDIDs() (ids []string) {
	if id := m.host_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostID resets all changes to the "host_id" edge.
func (m *NetworkMutation) ResetHostID() {
	m.host_id = nil
	m.clearedhost_id = false
}

// Where appends a list predicates to the NetworkMutation builder.
func (m *NetworkMutation) Where(ps ...predicate.Network) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Network).
func (m *NetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.idx != nil {
		fields = append(fields, network.FieldIdx)
	}
	if m.mtu != nil {
		fields = append(fields, network.FieldMtu)
	}
	if m.name != nil {
		fields = append(fields, network.FieldName)
	}
	if m.mac != nil {
		fields = append(fields, network.FieldMAC)
	}
	if m.flags != nil {
		fields = append(fields, network.FieldFlags)
	}
	if m.addrs != nil {
		fields = append(fields, network.FieldAddrs)
	}
	if m.created_at != nil {
		fields = append(fields, network.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, network.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case network.FieldIdx:
		return m.Idx()
	case network.FieldMtu:
		return m.Mtu()
	case network.FieldName:
		return m.Name()
	case network.FieldMAC:
		return m.MAC()
	case network.FieldFlags:
		return m.Flags()
	case network.FieldAddrs:
		return m.Addrs()
	case network.FieldCreatedAt:
		return m.CreatedAt()
	case network.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case network.FieldIdx:
		return m.OldIdx(ctx)
	case network.FieldMtu:
		return m.OldMtu(ctx)
	case network.FieldName:
		return m.OldName(ctx)
	case network.FieldMAC:
		return m.OldMAC(ctx)
	case network.FieldFlags:
		return m.OldFlags(ctx)
	case network.FieldAddrs:
		return m.OldAddrs(ctx)
	case network.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case network.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Network field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case network.FieldIdx:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdx(v)
		return nil
	case network.FieldMtu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMtu(v)
		return nil
	case network.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case network.FieldMAC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMAC(v)
		return nil
	case network.FieldFlags:
		v, ok := value.(*pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlags(v)
		return nil
	case network.FieldAddrs:
		v, ok := value.(*pgtype.TextArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddrs(v)
		return nil
	case network.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case network.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkMutation) AddedFields() []string {
	var fields []string
	if m.addidx != nil {
		fields = append(fields, network.FieldIdx)
	}
	if m.addmtu != nil {
		fields = append(fields, network.FieldMtu)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case network.FieldIdx:
		return m.AddedIdx()
	case network.FieldMtu:
		return m.AddedMtu()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case network.FieldIdx:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdx(v)
		return nil
	case network.FieldMtu:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMtu(v)
		return nil
	}
	return fmt.Errorf("unknown Network numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(network.FieldFlags) {
		fields = append(fields, network.FieldFlags)
	}
	if m.FieldCleared(network.FieldAddrs) {
		fields = append(fields, network.FieldAddrs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMutation) ClearField(name string) error {
	switch name {
	case network.FieldFlags:
		m.ClearFlags()
		return nil
	case network.FieldAddrs:
		m.ClearAddrs()
		return nil
	}
	return fmt.Errorf("unknown Network nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkMutation) ResetField(name string) error {
	switch name {
	case network.FieldIdx:
		m.ResetIdx()
		return nil
	case network.FieldMtu:
		m.ResetMtu()
		return nil
	case network.FieldName:
		m.ResetName()
		return nil
	case network.FieldMAC:
		m.ResetMAC()
		return nil
	case network.FieldFlags:
		m.ResetFlags()
		return nil
	case network.FieldAddrs:
		m.ResetAddrs()
		return nil
	case network.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case network.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_id != nil {
		edges = append(edges, network.EdgeHostID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeHostID:
		if id := m.host_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_id {
		edges = append(edges, network.EdgeHostID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case network.EdgeHostID:
		return m.clearedhost_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkMutation) ClearEdge(name string) error {
	switch name {
	case network.EdgeHostID:
		m.ClearHostID()
		return nil
	}
	return fmt.Errorf("unknown Network unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkMutation) ResetEdge(name string) error {
	switch name {
	case network.EdgeHostID:
		m.ResetHostID()
		return nil
	}
	return fmt.Errorf("unknown Network edge %s", name)
}
